# ordersSample
Сервис демонстрирует пример работы с API cbr.ru

## Задача
В таблице orders представлены заказы и их стоимость в разных валютах.
В таблице order_passengers список пассажиров для каждого заказа.

1. Необходимо с сайта ЦБ РФ получить актуальный курс валют и вывести в браузер по GET-запросу http://localhost:3000/orders таблицу заказов:
Номер заказа | Локатор | Дата последнего обновления | Стоимость в рублях | Стоимость в валюте заказа | Количество пассажиров 
Причем значение в поле локатор ссылка вида: http://localhost:3000/order/#ЛОКАТОР#

2. При переходе по ссылке из поля локатор показываем табличку со списком пассажиров
Номер заказа | Локатор | Фамилия | Имя
Так же на данной странице должна быть возможность вернуться к списоку заказов.

## Решение

## Структура приложения
 - в качестве [config](./config) настройки приложения
 - в качестве [db](./db) выбрана sqlite
 - в [dao](./dao) находится обеспечивающий доступ к БД
 - в [controllers](./controllers) находятся контроллеры реализующие логику приложения
 - в [routes](./routes) описание роутинга приложения
 - в [views](./views) для фронтовой части использую Handlebars engine

## Алгоритм работы 
  - запускаю миграции
  - инициализирую БД
  - обновляю состояния заказов перед запуском системы
  - запускаю обновление заказов по таймеру
  - стартую сервер
 
 Примечание: Я использую временную таблицу tmp_orders_state, которая инициализируется перед стартом сервера и далее пересчитывается по таймеру (параметр timeUpdateOrderState в конфиге).
 Это позволяет не нагружать сервер расчетами не пересчитывать на каждый запрос "/orders",
 т.к. в нем присутствуют обращения к внешнем ресурсам (www.cbr.ru) и расчет курса для каждой строки.
 
## Как можно улучшить это решение: 
При разработке допущены некоторые упрощения, так как это демо-проект. Если готовил бы приложение для прода, то я бы еще добавил следующее:
 - использовать ORM (sequelize),
 - использовать memcached. Кеширование на уровне БД и использование temporary_table, конечно снимает проблему нагрузки на сервер, но в проде лучше использовать все-таки memcached.
 - Загружать bootstrap и скрипты на фронте из локальной директории, сейчас для демо используется CDN

## Запуск тестов   
 - `$ sudo npm run test` выполнить тесты
 - `$ sudo npm run coverage` посчитать покрытие кода тестами

## Результат
Список заказов:

![image](https://user-images.githubusercontent.com/18545939/64964906-b1c19200-d8a4-11e9-9391-47bf1ee628d8.png)

Список пассажиров:

![image](https://user-images.githubusercontent.com/18545939/64964966-c9007f80-d8a4-11e9-9f3a-f2027763b1b5.png)

тесты:

![image](https://user-images.githubusercontent.com/18545939/64964834-89399800-d8a4-11e9-8527-b70c96f47f9a.png)

Покрытие тестами:

![image](https://user-images.githubusercontent.com/18545939/64964779-67401580-d8a4-11e9-99e6-9589ca2a7bde.png)
